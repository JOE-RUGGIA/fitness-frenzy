<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Idle Clicker â€“ V0.2 (Mobile + GitHub Assets)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#111" />
  <style>
    :root {
      --bg: #0f1114;
      --card: #15181d;
      --ink: #e9eef3;
      --muted: #9aa7b3;
      --accent: #2e7d32;
      --accent-2: #256628;
      --border: #232a33;
      --radius: 14px;
      --space: clamp(10px, 2.2vw, 18px);
      --fs-1: clamp(16px, 2.4vw, 18px);
      --fs-2: clamp(18px, 3.2vw, 22px);
      --fs-3: clamp(22px, 5vw, 28px);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: env(safe-area-inset-top) var(--space) env(safe-area-inset-bottom) var(--space);
    }
    .wrap { max-width: 920px; margin: 0 auto; }
    header { display: flex; align-items: center; gap: var(--space); margin: var(--space) 0; }
    header img { width: clamp(28px, 6vw, 48px); height: auto; }
    h1 { font-size: var(--fs-3); margin: 0; font-weight: 700; letter-spacing: 0.2px; }

    .row { display: flex; gap: var(--space); flex-wrap: wrap; }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: var(--space);
      flex: 1 1 280px;
      min-width: 260px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset, 0 10px 24px rgba(0,0,0,0.25);
    }
    h3 { margin: 0 0 10px 0; font-size: var(--fs-2); }
    .muted { color: var(--muted); }
    .stat { font-variant-numeric: tabular-nums; }

    .btn {
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      padding: clamp(10px, 2.5vh, 14px) clamp(14px, 3vw, 18px);
      font-size: var(--fs-1);
      font-weight: 600;
      line-height: 1;
      cursor: pointer;
      transition: transform .02s ease-out, filter .12s ease;
      touch-action: manipulation;
      width: 100%;
    }
    .btn:active { transform: translateY(1px); filter: brightness(0.95); }
    .btn[disabled] { background: #3a434f; color: #a7b1be; cursor: not-allowed; transform: none; }
    .btn.secondary { background: #2b3c4f; }
    .btn.secondary:active { filter: brightness(1.08); }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: var(--space);
    }
    @media (max-width: 560px) {
      .grid-2 { grid-template-columns: 1fr; }
    }

    .flex { display: flex; align-items: center; gap: 10px; }
    .spacer { height: var(--space); }
    .status { min-height: 1.2em; }
    .row-compact { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .kpi { display:flex; align-items:center; gap:10px; }
    .kpi img { width: clamp(20px, 5vw, 28px); height: auto; filter: drop-shadow(0 2px 1px rgba(0,0,0,0.6)); }
    .switch { display:flex; align-items:center; gap:8px; font-size: var(--fs-1); }
    input[type="checkbox"] { width: 18px; height: 18px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <img id="coinImg" alt="Coin" />
      <h1>Idle Clicker</h1>
    </header>

    <div class="row">
      <div class="card">
        <h3>Bank</h3>
        <div class="kpi">
          <img id="coinImg2" alt="Coin" />
          <div>Coins: <span id="coins" class="stat">0</span></div>
        </div>
        <div class="muted">Per tap: <span id="perTap" class="stat">1</span></div>
        <div class="muted">Idle/sec: <span id="perSec" class="stat">0</span></div>
        <div class="spacer"></div>
        <div class="grid-2">
          <button id="tapBtn" class="btn">Tap (+)</button>
          <button id="saveBtn" class="btn secondary">Save</button>
          <button id="resetBtn" class="btn secondary">Hard Reset</button>
          <label class="switch">
            <input id="muteToggle" type="checkbox" />
            Mute
          </label>
        </div>
        <div id="status" class="muted status"></div>
      </div>

      <div class="card">
        <h3>Upgrades</h3>
        <div class="row-compact">
          <div>
            <div><strong>Auto-Tapper</strong></div>
            <div class="muted">Each adds 1 tap/sec (multiplier applies)</div>
            <div class="muted">Owned: <span id="autoOwned" class="stat">0</span></div>
          </div>
          <button id="buyAutoBtn" class="btn">Buy (cost <span id="autoCost" class="stat">15</span>)</button>
        </div>
        <div class="spacer"></div>
        <div class="row-compact">
          <div>
            <div><strong>Multiplier</strong></div>
            <div class="muted">+100% to taps & idle per level</div>
            <div class="muted">Level: <span id="multOwned" class="stat">1</span></div>
          </div>
          <button id="buyMultBtn" class="btn">Buy (cost <span id="multCost" class="stat">50</span>)</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // =======================
  // CONFIG (point to GitHub)
  // =======================
  // If left empty, the app will try local files (e.g., ./assets/images/coin.png)
  const CONFIG = {
    ASSET_BASE: "", // e.g., "https://YOUR-USERNAME.github.io/YOUR-REPO/assets"
    IMAGES: {
      coin: "images/coin.png"
    },
    SOUNDS: {
      tap: "sounds/click.wav",
      buy: "sounds/buy.wav"
    }
  };
  const url = (path) => {
    const base = (CONFIG.ASSET_BASE || "").replace(/\/$/, "");
    const clean = (path || "").replace(/^\//, "");
    return base ? `${base}/${clean}` : `./assets/${clean}`;
  };

  // ================
  // VERSION / SAVE
  // ================
  const VERSION = '0.2.0';
  const SAVE_KEY = 'idle_clicker_save_v' + VERSION;

  // ==========
  // STATE
  // ==========
  const state = {
    coins: 0,
    perTapBase: 1,
    multiplierLevel: 1,    // effective multiplier = level
    autoOwned: 0,          // each = 1 tap/sec baseline
    lastTS: performance.now(),
    lastSavedAt: Date.now(),
    muted: false
  };

  const costs = {
    auto: { base: 15, growth: 1.15 },
    mult: { base: 50, growth: 1.20 }
  };

  // ==========
  // UTIL
  // ==========
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const pow = Math.pow;
  const fmt = (n) => {
    if (n >= 1e12) return (n/1e12).toFixed(2) + 'T';
    if (n >= 1e9)  return (n/1e9 ).toFixed(2) + 'B';
    if (n >= 1e6)  return (n/1e6 ).toFixed(2) + 'M';
    if (n >= 1e3)  return (n/1e3 ).toFixed(2) + 'K';
    return Math.floor(n).toString();
  };
  function costFor(countOwned, { base, growth }) {
    return Math.floor(base * pow(growth, countOwned));
  }
  function totalPerTap() {
    return state.perTapBase * state.multiplierLevel;
  }
  function totalPerSec() {
    return state.autoOwned * totalPerTap();
  }

  // ==========
  // AUDIO
  // ==========
  const sfx = {
    tap: new Audio(url(CONFIG.SOUNDS.tap)),
    buy: new Audio(url(CONFIG.SOUNDS.buy))
  };
  [sfx.tap, sfx.buy].forEach(a => {
    a.preload = 'auto';
    a.volume = 0.8;
  });

  let audioUnlocked = false;
  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    // Attempt a tiny silent play to satisfy iOS autoplay policies
    try { sfx.tap.muted = true; sfx.tap.play().then(() => { sfx.tap.pause(); sfx.tap.currentTime = 0; sfx.tap.muted = state.muted; }); } catch {}
  }
  function playSfx(aud) {
    if (state.muted) return;
    try {
      // Reuse element; quick sounds are fine with currentTime reset
      aud.currentTime = 0;
      aud.play();
    } catch {}
  }

  // ================
  // PERSISTENCE
  // ================
  function save() {
    const payload = {
      coins: state.coins,
      multiplierLevel: state.multiplierLevel,
      autoOwned: state.autoOwned,
      lastSavedAt: Date.now(),
      muted: state.muted,
      version: VERSION
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
    ui.status.textContent = 'Saved.';
    setTimeout(() => (ui.status.textContent = ''), 800);
  }
  function load() {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return;
    try {
      const s = JSON.parse(raw);
      state.coins = s.coins ?? state.coins;
      state.multiplierLevel = s.multiplierLevel ?? state.multiplierLevel;
      state.autoOwned = s.autoOwned ?? state.autoOwned;
      state.lastSavedAt = s.lastSavedAt ?? Date.now();
      state.muted = !!s.muted;

      // Offline progress (cap at 24h)
      const secs = clamp((Date.now() - state.lastSavedAt) / 1000, 0, 60 * 60 * 24);
      state.coins += totalPerSec() * secs;
    } catch { /* ignore */ }
  }

  // ================
  // ECONOMY
  // ================
  function canAfford(cost) { return state.coins >= cost; }
  function tap() {
    state.coins += totalPerTap();
    playSfx(sfx.tap);
  }
  function buyAuto() {
    const c = costFor(state.autoOwned, costs.auto);
    if (!canAfford(c)) return false;
    state.coins -= c;
    state.autoOwned += 1;
    playSfx(sfx.buy);
    return true;
  }
  function buyMult() {
    const c = costFor(state.multiplierLevel - 1, costs.mult);
    if (!canAfford(c)) return false;
    state.coins -= c;
    state.multiplierLevel += 1;
    playSfx(sfx.buy);
    return true;
  }

  // ==========
  // LOOP
  // ==========
  const STEP = 100; // ms (10Hz fixed update)
  let acc = 0;
  function update(dtMs) {
    acc += dtMs;
    while (acc >= STEP) {
      state.coins += (totalPerSec() * (STEP / 1000));
      acc -= STEP;
    }
  }
  function render() {
    ui.coins.textContent = fmt(state.coins);
    ui.perTap.textContent = fmt(totalPerTap());
    ui.perSec.textContent = fmt(totalPerSec());
    ui.autoOwned.textContent = state.autoOwned;
    ui.multOwned.textContent = state.multiplierLevel;

    const nextAutoCost = costFor(state.autoOwned, costs.auto);
    const nextMultCost = costFor(state.multiplierLevel - 1, costs.mult);
    ui.autoCost.textContent = fmt(nextAutoCost);
    ui.multCost.textContent = fmt(nextMultCost);
    ui.buyAutoBtn.disabled = !canAfford(nextAutoCost);
    ui.buyMultBtn.disabled = !canAfford(nextMultCost);
    ui.muteToggle.checked = state.muted;
  }
  function tick(ts) {
    const dt = ts - state.lastTS;
    state.lastTS = ts;
    update(dt);
    render();
    requestAnimationFrame(tick);
  }

  // ==========
  // UI
  // ==========
  const ui = {
    coins: document.getElementById('coins'),
    perTap: document.getElementById('perTap'),
    perSec: document.getElementById('perSec'),
    tapBtn: document.getElementById('tapBtn'),
    buyAutoBtn: document.getElementById('buyAutoBtn'),
    buyMultBtn: document.getElementById('buyMultBtn'),
    autoOwned: document.getElementById('autoOwned'),
    multOwned: document.getElementById('multOwned'),
    autoCost: document.getElementById('autoCost'),
    multCost: document.getElementById('multCost'),
    saveBtn: document.getElementById('saveBtn'),
    resetBtn: document.getElementById('resetBtn'),
    status: document.getElementById('status'),
    muteToggle: document.getElementById('muteToggle'),
    coinImg: document.getElementById('coinImg'),
    coinImg2: document.getElementById('coinImg2')
  };

  // Mobile-friendly: single "press" binding with Pointer Events
  function bindPress(el, handler) {
    el.addEventListener('pointerdown', (e) => {
      e.preventDefault(); // prevents 300ms delay + accidental text selection
      unlockAudioOnce();
      handler(e);
    }, { passive: false });
    // Keyboard accessibility
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handler(e); }
    });
  }

  bindPress(ui.tapBtn, () => { tap(); render(); });
  bindPress(ui.buyAutoBtn, () => { if (buyAuto()) render(); });
  bindPress(ui.buyMultBtn, () => { if (buyMult()) render(); });
  bindPress(ui.saveBtn, save);
  bindPress(ui.resetBtn, () => {
    if (!confirm('Hard reset? This clears your save.')) return;
    localStorage.removeItem(SAVE_KEY);
    location.reload();
  });
  ui.muteToggle.addEventListener('change', () => {
    state.muted = ui.muteToggle.checked;
    sfx.tap.muted = state.muted;
    sfx.buy.muted = state.muted;
  });

  // ==========
  // BOOT
  // ==========
  function boot() {
    // Set coin images (works with GitHub or local assets/)
    const coinURL = url(CONFIG.IMAGES.coin);
    ui.coinImg.src = coinURL;
    ui.coinImg2.src = coinURL;

    load();
    render();

    requestAnimationFrame((ts) => {
      state.lastTS = ts;
      requestAnimationFrame(tick);
    });

    // auto-save every 15s
    setInterval(save, 15000);
  }

  boot();
  </script>
</body>
</html>
